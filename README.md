<!--
Роль: витрина проекта + инварианты.
-->


## Что это за проект

**Structure-Text Orchestrator** — это state-driven LLM-пайплайн для проектирования структуры SEO-текстов для медицинской клиники без генерации финального контента.

Проект не пишет статьи.  
Проект **архитектурно проектирует текст**: определяет структуру, секции, смысловые блоки, покрытие ключевых слов, ограничения YMYL и правила перелинковки — строго по этапам и контрактам.

Ключевая идея:  
LLM работает не как «писатель», а как **исполнитель архитектурных проходов (passes)** с жёсткими контрактами входа и выхода.

---

## Исходный источник логики

Проект реализует и формализует логику промпта: **`Структура текста.md`**. По необходимости запрашивай файл **`Структура текста.md`**, чтоб понять контекст разрабатываемого проекта **`Structure-Text Orchestrator`**

Этот файл является:
- концептуальным источником архитектуры,
- логической основой всех PASS-проходов,
- эталоном требований к структуре текста.

Оркестратор превращает этот промпт из «ручного» в **детерминированный, воспроизводимый пайплайн**.

---

## Для чего нужен проект

Проект используется, когда:
- нельзя допускать «самодеятельность» LLM,
- важно разделить **архитектуру текста** и **его написание**,
- требуется контроль YMYL, каннибализации, структуры и интента,
- нужен повторяемый результат при одинаковых входных данных.

Типовые кейсы:
- SEO-страницы клиник (симптомы, заболевания, услуги),
- медицинские и YMYL-тексты,
- масштабирование структуры страниц без генерации контента.

---

## Структура проекта
structure-text/
├─ README.md
│
├─ docs/
│  ├─ CHANGELOG.md
│  ├─ RUNBOOK_NEW_CHAT.md
│  ├─ STATE_CONTRACT.md
│  ├─ WORKFLOW.md
│  ├─ workflow_overview.md
│  └─ conventions.md
│
├─ state/
│  ├─ state_schema.json
│  └─ examples/
│     └─ state_initial.json
│
├─ passes/
│  ├─ pass_1_decide/
│  │  ├─ contract.md
│  │  └─ prompt.md
│  │
│  ├─ pass_2_execute/
│  │  ├─ contract.md
│  │  └─ prompt.md
│  │
│  ├─ pass_3_verify/
│  │  ├─ contract.md
│  │  └─ prompt.md
│  │
│  └─ pass_4_patch/
│     ├─ contract.md
│     └─ prompt.md
│
├─ jobs/
│  ├─ job_0001/  (исторический прогон)
│  │  ├─ input/
│  │  ├─ state/
│  │  └─ output/
│  │
│  └─ job_0002/  (канонический прогон: PASS 1–3 = PASS, issues = 0)
│     ├─ input/
│     ├─ state/
│     └─ output/
│
└─ orchestrator/
   └─ logic.md

---

## Ключевые принципы

<!-- AUTOGEN:BEGIN STATE_SUMMARY -->
### Текущее состояние проекта (автоген из state.json)

- Канонический job: **job_0002**
- schema_version: `1.0`
- created_at: `2026-01-02T20:00:00+03:00`
- last_updated_at: `2026-01-04T00:20:00+03:00`
- immutable_snapshot: **LOCKED** (hash: `decide0002`)
- status: phase=`VERIFY`, run_state=`COMPLETED`

### PASS статус

| PASS | status | started_at | ended_at | errors | notes |
|---|---|---|---|---:|---|
| decide | PASS | 2026-01-04T00:00:00+03:00 | 2026-01-04T00:00:00+03:00 | 0 |  |
| execute | PASS | 2026-01-04T00:10:00+03:00 | 2026-01-04T00:10:00+03:00 | 0 | artifact_ref=jobs/job_0002/output/pass_2_execute__out.json |
| verify | PASS | 2026-01-04T00:20:00+03:00 | 2026-01-04T00:20:00+03:00 | 0 | issues=0 |
| patch | NOT_RUN | 2026-01-02T20:00:00+03:00 | 2026-01-02T20:00:00+03:00 | 0 |  |

### VERIFY issues (по severity)

- BLOCKER: **0**
- MAJOR: **0**
- MINOR: **0**
- issues_total: **0**

### Как обновить документацию

```bash
python scripts/update_docs.py --state jobs/job_0002/state/state.json
```
<!-- AUTOGEN:END STATE_SUMMARY -->
---

## Почему это корректно (и важно)
- Мы **не трогаем архитектуру README**.
- Мы **не дублируем state.json вручную**.
- Мы явно фиксируем: этот блок — **проекция state**, а не “описание на глаз”.
- Это полностью совместимо с будущей автоматизацией README / STATUS / CHANGELOG.

---

### Что ты делаешь сейчас
1. Вносишь **ровно эту замену** в `README.md`.
2. Присылаешь:
   - либо diff,
   - либо фрагмент README **с 15–20 строками до и после блока**.

Если маркеры стоят криво или ты вставишь не туда — я скажу.  
Если всё чисто — переходим к **следующему шагу**.


### 1. State — единственный источник правды
Все проходы (PASS) читают **только `state.json`**.  
Наличие файлов в `output/` без фиксации в state считается отсутствием результата.

### 2. Строгое разделение этапов
Каждый PASS:
- имеет собственный контракт,
- запрещает лишние действия,
- может быть заблокирован предыдущим этапом.

### 3. Запрет на генерацию финального текста
Проект **никогда** не генерирует готовые статьи.  
Результат — **structure_spec**, а не Markdown-контент.

---

## Архитектура пайплайна

### PASS 1 — DECIDE
**Цель:** архитектурное решение

- Проверяет входные данные
- Определяет допустимый scope
- Фиксирует:
  - что разрешено
  - что запрещено
  - требования YMYL
  - риски каннибализации
- Лочит immutable_snapshot

**Результат:** `architecture_decision_json`

---

### PASS 2 — EXECUTE
**Цель:** построение структуры

- Работает только при LOCKED snapshot
- Генерирует **structure_spec**:
  - H1 / H2 / H3
  - назначение секций
  - покрытие ключей и LSI
  - правила перелинковки
  - антиканнибализационные заметки
- Формат: **строгий JSON**

**Запрещено:**  
- генерация текста статьи  
- Markdown  
- prose-абзацы  

---

### PASS 3 — VERIFY
**Цель:** аудит результата

VERIFY не исправляет структуру и не принимает архитектурных решений.  
Его задача — зафиксировать качество результата PASS 2 и определить,
допустим ли переход к PATCH или требуется осознанное принятие рисков.

- Проверяет structure_spec на соответствие:
  - архитектурному решению
  - ключам
  - YMYL-требованиям
  - ограничениям scope
- Возвращает issues:
  - BLOCKER
  - MAJOR
  - MINOR

---

### PASS 4 — PATCH (опционально)
**Цель:** точечные исправления

- Работает только по issue из VERIFY
- Не меняет архитектуру
- Исправляет:
  - недостающие секции
  - некорректное распределение ключей
  - формальные нарушения

---

## Входные данные (Input Contract)

Проект **не принимает “просто текст”**.  
На вход подаётся структурированный объект:

```json
{
  "topic": "...",
  "clinic": "...",
  "page_type": "...",
  "target_url": "...",
  "competitors": [],
  "keywords": [],
  "lsi": [],
  "anti_cannibalization_urls": []
}
```

---

## Документация проекта

Подробная документация и операционные инструкции вынесены в отдельные файлы:

- `docs/WORKFLOW.md` — логика 4-проходного пайплайна (DECIDE → EXECUTE → VERIFY → PATCH)
- `docs/STATE_CONTRACT.md` — контракт state.json и правила работы с состоянием
- `docs/RUNBOOK_NEW_CHAT.md` — обязательный порядок переноса проекта в новый чат
- `jobs/{job_id}/STATUS.md` — человекочитаемый статус конкретного прогона