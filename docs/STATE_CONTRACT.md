<!--
Роль: контракт состояния (state).
Определяет:
- что считается источником истины,
- какие поля допустимо изменять вручную,
- какие поля являются производными и НЕ трогаются руками,
- как интерпретируются результаты PASS’ов,
- приоритет state над файловой системой.
-->

# STATE CONTRACT

## 1. Source of Truth

Единственным источником истины в проекте является `state.json`.

Ни один файл в файловой системе (включая `output/`, `STATUS.md`, артефакты PASS’ов)
**не имеет значения**, если он не зафиксирован в `state.json`.

**Правило:**
> Файл существует ≠ результат существует.  
> Результат существует **только**, если он отражён в state.

---

## 2. Структура state.json (логически)

`state.json` состоит из двух принципиально разных частей:

1. **passes.\*** — ручное, осознанное состояние
2. **status.\*** — вычисляемое, производное состояние

Смешивание этих ролей запрещено.

---

## 3. Допустимые ручные изменения

### Разрешено изменять вручную:

- `passes.decide`
- `passes.execute`
- `passes.verify`
- `passes.patch`

Включая:
- `status` конкретного PASS (`PASS`, `FAIL`, `NOT_RUN`)
- `result` (включая `artifact_ref`, issues и др.)
- вспомогательные метаданные PASS’а

**Предположение:**  
Ручные изменения делаются осознанно и соответствуют контракту конкретного PASS.

---

## 4. Запрещённые ручные изменения

### Категорически запрещено изменять вручную:

- `status.phase`
- `status.run_state`
- любые агрегированные или вычисляемые поля статуса

**Причина:**  
Эти поля являются **производными** и вычисляются на основе `passes.*`.

Любая ручная правка этих полей считается:
- нарушением state-контракта,
- источником недетерминированного поведения пайплайна.

---

## 5. Вычисление status.\*

`status.phase` и `status.run_state` вычисляются автоматически
на основе текущего состояния `passes.*`.

Общее правило:

- если есть PASS с `FAIL` → `run_state = FAILED`
- если есть незавершённые обязательные PASS’ы → `run_state = IN_PROGRESS`
- если достигнут VERIFY без BLOCKER → `run_state = READY_FOR_PATCH`
- если PATCH завершён → `run_state = COMPLETED`

Точная логика вычисления может эволюционировать,
но **ручное вмешательство запрещено всегда**.

---

## 6. artifact_ref и приоритет state над filesystem

Поле `artifact_ref` внутри PASS’а:

- указывает путь к файлу,
- **не гарантирует**, что файл существует,
- **не делает файл источником истины**.

Правило интерпретации:

- `artifact_ref` существует в state → результат считается существующим
- файл существует без `artifact_ref` → результат считается отсутствующим
- файл удалён, но `artifact_ref` есть → состояние неконсистентно (ошибка среды)

VERIFY и PATCH **читают только state**, а не файловую систему.

---

## 7. STATUS.md

`STATUS.md` — человекочитаемый, производный артефакт.

- не является источником истины
- может быть удалён и восстановлен
- в текущей версии проекта заполняется вручную

### Обязательный TODO

Автоматизировать генерацию `STATUS.md` из `state.json`
через `tools/render_status.py`
после стабилизации схемы state (версия v1.0).

---

## 8. Нарушения state-контракта

К нарушениям state-контракта относятся:

- ручное изменение `status.phase` или `status.run_state`
- интерпретация файлов без фиксации в state
- выполнение PASS’а, не разрешённого текущей `status.phase`
- пересборка архитектуры после LOCKED snapshot

Любое нарушение state-контракта делает дальнейшую работу пайплайна недостоверной.

---

## 9. Версионность контракта

Данный контракт относится к версии проекта **v0.x**.

Изменения структуры state или правил вычисления статуса:
- фиксируются в `CHANGELOG.md`
- сопровождаются повышением версии контракта

Без фиксации в CHANGELOG изменение контракта считается недействительным.
